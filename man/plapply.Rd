% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/helpers.R
\name{plapply}
\alias{plapply}
\title{Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.}
\usage{
plapply(
  ...,
  progress = FALSE,
  n.cores = parallel::detectCores(),
  mc.preschedule = FALSE,
  fail.on.error = FALSE
)
}
\arguments{
\item{...}{Additional arguments passed to mclapply(), lapply(), or pbapply::pblapply()}

\item{progress}{Show progress bar via pbapply::pblapply() (default=FALSE). Note: we've noticed performance issues with pbapply::pblapply(). 
The function splits the tasks into batches corresponding to the steps of the progress bar, and waits for all the tasks in each batch to complete before scheduling additional ones. For variable-sized tasks this results in low degree of parallelism and increased overall runtime.}

\item{n.cores}{Number of cores to use (default=parallel::detectCores()). When n.cores=1, regular lapply() is used. Note: doesn't work when progress=TRUE}

\item{mc.preschedule}{See ?parallel::mclapply (default=FALSE) If TRUE then the computation is first divided to (at most) 
as many jobs are there are cores and then the jobs are started, each job possibly covering more than one value. 
If FALSE, then one job is forked for each value of X. The former is better for short computations or large number of values in X, the latter is better for jobs that have high variance of completion time and not too many values of X compared to mc.cores.}

\item{fail.on.error}{boolean Whether to fail and report and error (using stop()) as long as any of the individual tasks has failed (default =FALSE)}
}
\value{
list, as returned by lapply
}
\description{
Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.
}
\examples{
square = function(x){ x**2 }
plapply(1:10, square, n.cores=1, progress=TRUE)

}
